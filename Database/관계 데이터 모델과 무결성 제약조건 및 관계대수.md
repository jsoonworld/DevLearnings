
# **1. 관계 데이터 모델의 개념**

# 릴레이션

- **릴레이션**: 
  - 행과 열로 구성된 테이블을 말한다. 데이터베이스의 기본 구조로, 모든 데이터는 릴레이션 형태로 저장된다.
  
- **속성(Attribute)**: 
  - 릴레이션의 세로 값으로, 각 열(Column)을 의미합니다. 속성은 데이터의 특성을 나타내며, 각 속성은 특정한 데이터 타입을 가진다.
  
- **튜플(Tuple)**: 
  - 릴레이션의 가로 값으로, 각 행(Row)을 의미한다. 튜플은 데이터베이스의 한 레코드를 나타내며, 각 튜플은 속성의 값을 가진다.
  
- **차수(Degree)**: 
  - 릴레이션의 속성의 수를 의미한다. 예를 들어, 릴레이션이 5개의 속성을 가지고 있다면, 그 릴레이션의 차수는 5이다.
  
- **카디날리티(Cardinality)**: 
  - 릴레이션의 튜플의 수를 의미한다. 예를 들어, 릴레이션에 10개의 튜플이 있다면, 그 릴레이션의 카디날리티는 10이다.
  
- **인스턴스(Instance)**: 
  - 정의된 스키마에 따라 테이블에 실제 저장된 데이터의 집합을 의미한다. 인스턴스는 특정 시점에 릴레이션에 저장된 데이터를 나타낸다.
  
- **스키마(Schema)**: 
  - 릴레이션이 어떻게 구성되는지, 어떤 정보를 담고 있는지에 대한 기본적인 구조를 정의한다. 스키마는 릴레이션의 구조(속성의 이름, 데이터 타입 등)를 정의하며, 일반적으로 첫 행의 헤더에 해당한다.


### 스키마의 구성 요소

스키마는 데이터베이스 구조를 정의하는 데 사용되는 기본적인 개념이다. 스키마는 릴레이션(테이블)의 구조를 설명하며, 주로 다음과 같은 구성 요소로 이루어져 있다:

1. **속성(Attribute)**:
    
    - 릴레이션 스키마의 열(Column)을 의미한다.
    - 예시: 학생 테이블에서 속성은 학생ID, 이름, 학년, 전공 등이 될 수 있다.
2. **도메인(Domain)**:
    
    - 속성이 가질 수 있는 값의 집합을 의미한다.
    - 예시: 학생ID는 정수(Integer) 타입, 이름은 문자열(Varchar(50)) 타입, 학년은 1에서 4 사이의 정수 등.
3. **차수(Degree)**:
    
    - 릴레이션의 속성의 개수를 의미한다.
    - 예시: 학생 테이블에서 속성이 4개라면, 차수는 4가 된다.

### 인스턴스의 구성 요소

인스턴스는 데이터베이스 테이블에 실제 저장된 데이터의 집합을 의미한다. 인스턴스의 구성 요소는 다음과 같다:

1. **튜플(Tuple)**:
    
    - 릴레이션의 행(Row)을 의미한다.
    - 각 튜플은 릴레이션의 한 레코드를 나타낸다.
2. **카디날리티(Cardinality)**:
    
    - 릴레이션의 튜플의 수를 의미한다.
    - 예를 들어, 테이블에 10개의 튜플이 있다면, 그 릴레이션의 카디날리티는 10이다.

여기서 튜플이 가지는 속성의 개수는 릴레이션 스키마의 차수와 동일하며, 릴레이션 내의 모든 튜플은 서로 중복되지 않아야 한다.


### 릴레이션의 특징

릴레이션에는 다음과 같은 특징이 있다:

1. **속성은 단일 값을 가진다**:
    
    - 각 속성은 하나의 값만 가질 수 있으며, 쪼개지지 않는 원자값을 가진다. 예를 들어, 한 책의 가격은 7000원 또는 8000원 중 하나의 값만 가질 수 있다. 가격이 7000, 8000과 같이 두 개의 값을 동시에 가질 수 없다.
2. **속성은 서로 다른 이름을 가진다**:
    
    - 릴레이션 내에서 같은 이름의 속성은 존재할 수 없다. 예를 들어, 이름, 이름, 이름과 같은 동일한 속성 이름이 올 수 없습니다.
3. **한 속성의 값은 모두 같은 도메인 값을 가진다**:
    
    - 한 속성의 모든 값은 같은 도메인(데이터 타입)을 가져야 한다.
4. **속성의 순서는 상관이 없다**:
    
    - 릴레이션 내에서 속성의 순서는 데이터의 의미에 영향을 주지 않는다. 속성의 순서는 중요하지 않다.
5. **릴레이션 내의 중복된 튜플은 허용하지 않는다**:
    
    - 릴레이션 내에서 동일한 튜플(레코드)이 중복되어 존재할 수 없다. 모든 속성의 값이 동일한 튜플은 한 릴레이션 내에 존재할 수 없다.
6. **튜플의 순서는 상관없다**:
    
    - 릴레이션 내에서 튜플의 순서는 데이터의 의미에 영향을 주지 않는다. 튜플의 순서는 중요하지 않다.

### 관계 데이터 모델

관계 데이터 모델은 데이터를 2차원 테이블 형태인 릴레이션으로 표현한 데이터 모델이다. 이 모델은 다음과 같은 구성 요소로 이루어져 있다:

1. **릴레이션(Relation)**:
    
    - 데이터를 행과 열로 구성된 2차원 테이블 형태로 표현한다.
    - 각 릴레이션은 고유한 이름을 가지며, 행(Row)을 튜플(Tuple), 열(Column)을 속성(Attribute)이라고 한다.
2. **제약조건(Constraints)**:
    
    - 릴레이션에 저장되는 데이터에 대한 규칙을 정의한다.
    - 제약조건은 데이터의 무결성을 유지하기 위해 사용되며, 대표적으로 기본키(Primary Key), 외래키(Foreign Key), 고유성(Unique), 널(Null) 여부 등이 있다.
3. **관계대수(Relational Algebra)**:
    
    - 릴레이션에서 데이터를 검색하고 조작하기 위한 연산자들의 집합이다.
    - 관계대수는 데이터베이스 질의 언어(SQL)의 이론적 기초를 이루며, 주요 연산자로는 선택(Select), 투영(Project), 합집합(Union), 교집합(Intersection), 차집합(Difference), 조인(Join) 등이 있다.

### 관계 데이터 모델의 구현

이러한 관계 데이터 모델을 컴퓨터에 구현한 시스템을 **관계 데이터베이스 시스템**이라고 한다. 관계 데이터베이스 시스템은 데이터를 저장, 관리, 검색하는 데 사용되며, SQL을 사용하여 데이터베이스와 상호작용한다.

# **2. 무결성 제약조건**

### 키(KEY)

키(Key)는 특정 튜플을 식별할 때 사용하는 속성 또는 속성의 집합을 의미한다. 키는 데이터베이스에서 중요한 역할을 하며, 다음과 같은 특징과 역할을 가지고 있다:

- **특정 튜플 식별**:
    
    - 키가 되는 속성(혹은 속성의 집합)은 값이 반드시 달라서 튜플들을 구별할 수 있어야 한다.
    - 각 튜플을 고유하게 식별하기 위해 사용된다.
- **릴레이션 간의 관계**:
    
    - 키는 릴레이션 간의 관계를 맺는 데도 사용된다.
    - 예를 들어, 외래키(Foreign Key)는 다른 릴레이션의 기본키(Primary Key)를 참조하여 릴레이션 간의 관계를 설정한다.
- **중복 방지**:
    
    - 한 릴레이션에서 중복되는 튜플들은 존재할 수 없다.
    - 따라서, 각각의 튜플에 포함된 속성들 중 어느 하나(혹은 하나 이상)은 값이 달라져야 하며, 이를 통해 각 튜플을 식별하는 역할을 키가 담당한다.

일반적으로 키는 단일 속성으로 지정되지만, 단일 속성으로 각 튜플을 고유하게 식별할 수 없는 경우에는 두 개 이상의 속성을 묶어 키로 사용할 수 있다.

### 슈퍼키(Super Key)

슈퍼키는 튜플을 유일하게 식별할 수 있는 하나의 속성 또는 속성의 집합을 의미한다. 즉, 튜플을 식별할 수 있으면 모두 슈퍼키가 될 수 있다.

### 후보키(Candidate Key)

후보키는 튜플을 유일하게 식별할 수 있는 속성의 최소 집합을 의미한다. 후보키는 유일성을 보장하며, 한 릴레이션에서 여러 개의 후보키가 존재할 수 있다.

### 기본키(Primary Key)

기본키는 여러 후보키 중 하나를 선정하여 대표로 삼는 키를 의미한다. 기본키는 릴레이션 내의 튜플을 고유하게 식별하며, 각 릴레이션에는 하나의 기본키가 존재한다.

#### 기본키의 선택

- **후보키가 하나뿐인 경우**:
    
    - 그 후보키를 기본키로 사용한다.
- **후보키가 여러 개인 경우**:
    
    - 릴레이션의 특성을 반영하여 하나의 후보키를 선택한다.


### 기본키 선정 시 고려사항

기본키를 선정할 때 다음과 같은 사항을 고려해야 한다:

1. **고유한 값**:
    
    - 릴레이션 내의 튜플을 식별할 수 있는 고유한 값을 가져야 한다.
    - 기본키는 각 튜플을 고유하게 식별할 수 있어야 한다.
2. **NULL 값 허용 불가**:
    
    - 기본키는 NULL 값을 허용하지 않는다.
    - NULL 값이 있으면 다른 튜플과 구별할 수 없기 때문이다.
3. **값의 변동 금지**:
    
    - 기본키의 값은 변동되지 않아야 한다.
    - 기본키가 변경되면 릴레이션 내에서 중복이 발생할 수 있다.
4. **적은 수의 속성**:
    
    - 가능한 한 적은 수의 속성을 가지는 것이 좋다.
    - 이는 효율적인 데이터베이스 관리를 위해 중요하다.
5. **향후 문제 발생 가능성 최소화**:
    
    - 향후 키를 사용하는 데 있어 문제 발생 소지가 없어야 한다.
    - 안정적인 데이터베이스 관리를 위해 필수적이다.

기본키가 NULL 값이 되면 다른 튜플과 식별할 수 없으므로 기본키는 NULL 값을 가질 수 없다. 또한, 기본키의 값이 변동되면 릴레이션 내에서 기본키를 제외하고 나머지 속성이 동일한 튜플이 중복될 수 있다.

### 대체키(Alternate Key)

대체키는 기본키로 선정되지 않은 후보키를 의미한다. 예를 들어, 고객 릴레이션에서 고객번호와 주민번호가 후보키인 경우, 고객번호를 기본키로 선택하면 주민번호는 대체키가 된다.

### 외래키(Foreign Key)

외래키는 다른 릴레이션의 기본키를 참조하는 속성을 의미한다. 외래키는 릴레이션 간의 관계를 설정하는 데 사용된다. 외래키는 NULL 값이 되어도 상관이 없다.

### 외래키(Foreign Key)와 자기 참조(Self-Referencing)

외래키는 한 릴레이션의 기본키를 다른 릴레이션에서 참조하는 속성을 의미하지만, 참조하는 릴레이션과 참조되는 릴레이션이 꼭 다를 필요는 없다. 즉, 한 릴레이션 내에서 자기 자신의 기본키를 외래키로 설정할 수도 있다.

### 무결성 제약조건

데이터 무결성(Integrity)은 데이터베이스에 저장된 데이터의 일관성과 정확성을 지키는 것을 말한다. 이를 위해 다음과 같은 무결성 제약조건을 사용한다:

1. **도메인 무결성 제약조건**
2. **개체 무결성 제약조건**
3. **참조 무결성 제약조건**

#### 1. 도메인 무결성 제약조건

도메인 무결성 제약조건은 도메인 제약(Domain Constraint)이라고도 하며, 릴레이션 내의 튜플들이 각 속성의 도메인에 지정된 값만을 가져야 한다는 조건이다. SQL문에서 데이터 형식(Type), 널(Null/Not Null), 기본 값(Default), 체크(Check) 등을 사용하여 지정할 수 있다.

**예시**:

- VARCHAR형으로 선언된 `Name`이라는 변수에는 정수형 Integer 값이 올 수 없다.

```sql
CREATE TABLE Students (
    StudentID INT,
    Name VARCHAR(50) NOT NULL,
    Age INT CHECK (Age >= 0)
);
```

#### 2. 개체 무결성 제약조건

개체 무결성 제약조건은 기본키 제약(Primary Key Constraint)이라고도 한다. 릴레이션은 기본키를 지정하고 그에 따른 무결성 원칙을 지켜야 한다. 즉, 기본키는 NULL 값을 가져서는 안 되며, 릴레이션 내에 오직 하나의 값만 존재해야 한다.

- **예시**:
    - 기본키는 릴레이션 내에서 튜플들을 구별할 수 있게 해주는 속성이다.
```sql
CREATE TABLE Students (
    StudentID INT PRIMARY KEY,
    Name VARCHAR(50) NOT NULL,
    Age INT CHECK (Age >= 0)
);
```

#### 3. 참조 무결성 제약조건

참조 무결성 제약조건은 외래키 제약(Foreign Key Constraint)이라고도 하며, 릴레이션 간의 참조 관계를 선언하는 제약조건이다. 자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 동일해야 하며, 자식 릴레이션의 값이 변경될 때 부모 릴레이션의 제약을 받아야 한다.

- **예시**:
    - 자식 릴레이션의 외래키는 부모 릴레이션의 기본키를 참조해야 한다.
```sql
CREATE TABLE Courses (
    CourseID INT PRIMARY KEY,
    CourseName VARCHAR(50) NOT NULL
);

CREATE TABLE Enrollments (
    EnrollmentID INT PRIMARY KEY,
    StudentID INT,
    CourseID INT,
    FOREIGN KEY (StudentID) REFERENCES Students(StudentID),
    FOREIGN KEY (CourseID) REFERENCES Courses(CourseID)
);

```

### 요약

- **도메인 무결성 제약조건**: 각 속성의 도메인에 지정된 값만을 가져야 한다는 조건.
- **개체 무결성 제약조건**: 기본키는 NULL 값을 가질 수 없고, 릴레이션 내에서 유일한 값을 가져야 한다는 조건.
- **참조 무결성 제약조건**: 자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 동일해야 하며, 부모 릴레이션의 제약을 받아야 한다는 조건.

# **3. 관계 대수(Relation Algebra)**

### 관계대수(Relational Algebra)

관계대수는 릴레이션에서 원하는 결과를 얻기 위해 연산을 이용하여 질의하는 방법을 기술하는 언어이다. 이는 데이터베이스 관리 시스템(DBMS) 내부에서 사용되는 절차적인 언어로, 데이터를 어떻게 찾는지에 대한 처리 절차를 명시한다.

#### 특징

- **절차적 언어**: 관계대수는 어떤 데이터를 어떻게 찾는지에 대한 절차를 명시한다.
- **DBMS 내부 처리 언어**: 관계대수는 DBMS 내부에서 사용되는 처리 언어이다.

### 관계해석(Relational Calculus)

관계해석은 어떤 데이터를 찾는지만 명시하는 선언적인 언어이다. 이는 관계대수와 함께 관계 DBMS의 표준 언어인 SQL의 이론적 기반을 제공한다.

#### 특징

- **선언적 언어**: 관계해석은 어떤 데이터를 찾는지에 대해 명시한다.
- **SQL의 이론적 기반**: 관계대수와 함께 SQL의 이론적 기반을 제공한다.

### 관계대수와 관계해석의 표현 능력

관계대수와 관계해석은 모두 관계 데이터 모델의 중요한 언어이며 동일한 표현능력을 가지고 있다.

### 카티전 프로덕트(Cartesian Product)

카티전 프로덕트는 두 집합의 모든 가능한 쌍을 만드는 연산이다. 예를 들어, 집합 A와 B가 다음과 같을 때:

- A = {2, 4}
- B = {1, 3, 5}

카티전 프로덕트 AxB는 다음과 같다:

- AxB = {(2,1), (2,3), (2,5), (4,1), (4,3), (4,5)}

릴레이션 R은 카티전 프로덕트의 부분집합으로 정의된다. 예를 들면:

- R1 = {(2,1), (4,3)}
- R2 = {(2,1), (2,3), (4,5)}

원소 개수가 n인 집합 S의 부분집합의 개수는 2n2^n2n이므로, 카티전 프로덕트 AxB의 부분집합의 개수는 2∣A∣∗∣B∣2^{|A|*|B|}2∣A∣∗∣B∣이다.

카티전 프로덕트의 기초 집합 A, B 각각이 가질 수 있는 값의 범위를 도메인(Domain)이라고 하며, A의 도메인은 {2, 4}이다. 릴레이션도 집합이므로 합집합, 교집합, 카티전 프로덕트 등의 연산을 수행할 수 있다.

예시: 카티전 프로덕트
```plaintext
A = {2, 4}
B = {1, 3, 5}
AxB = {(2,1), (2,3), (2,5), (4,1), (4,3), (4,5)}
R1 = {(2,1), (4,3)}
R2 = {(2,1), (2,3), (4,5)}
```

### 요약

- **관계대수**: 데이터를 어떻게 찾는지에 대한 처리 절차를 명시하는 절차적 언어.
- **관계해석**: 어떤 데이터를 찾는지만 명시하는 선언적 언어.
- **카티전 프로덕트**: 두 집합의 모든 가능한 쌍을 만드는 연산.
- **도메인**: 카티전 프로덕트의 기초 집합이 가질 수 있는 값의 범위.

### 관계대수 연산

관계대수 연산은 데이터베이스에서 릴레이션을 조작하고 원하는 결과를 얻기 위해 사용하는 연산이다. 관계대수 연산은 단항 연산자와 이항 연산자로 구분된다.

- **단항 연산자**: 연산자<조건> 릴레이션
- **이항 연산자**: 릴레이션1 연산자<조건> 릴레이션2

### 조인(Join)

조인은 두 릴레이션의 공통 속성을 기준으로 속성 값이 같은 튜플(Tuple)을 수평으로 결합하는 연산이다. 조인을 수행하기 위해서는 두 릴레이션의 조인에 참여하는 속성이 서로 동일한 도메인으로 구성되어야 한다. 조인 연산의 결과는 공통 속성의 속성 값이 동일한 튜플만을 반환한다.

#### 조인의 종류

1. **세타조인 (Theta Join)**:
    
    - 조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 튜플만 반환한다.
2. **동등조인 (Equi Join)**:
    
    - 세타조인에서 = 연산자를 사용한 조인이다.
3. **자연조인 (Natural Join)**:
    
    - 동등조인에서 조인에 참여한 속성이 두 번 나오지 않도록 두 번째 속성을 제거한 결과를 반환한다.
4. **외부조인 (Outer Join)**:
    
    - 자연조인 시 조인에 실패한 튜플을 모두 보여주되, 값이 없는 대응 속성에는 NULL 값을 채워서 반환한다. 기준 릴레이션의 위치에 따라 왼쪽 외부조인(Left Outer Join), 오른쪽 외부조인(Right Outer Join), 완전 외부조인(Full Outer Join)으로 나뉜다.
5. **세미조인 (Semi Join)**:
    
    - 자연조인을 한 후 두 릴레이션 중 한쪽 릴레이션의 결과만 반환하며, 기호에서 닫힌 쪽 릴레이션의 튜플만 반환한다

### 디비전(Division)

디비전 연산은 릴레이션의 속성 값의 집합으로 연산을 수행한다.

- **형식**: R÷SR \div SR÷S

### 요약

- **관계대수 연산**:
    - 단항 연산자와 이항 연산자로 구분된다.
- **조인(Join)**:
    - 두 릴레이션의 공통 속성을 기준으로 속성 값이 같은 튜플을 결합하는 연산이다.
    - 조인의 종류: 세타조인, 동등조인, 자연조인, 외부조인, 세미조인
- **디비전(Division)**:
    - 릴레이션의 속성 값의 집합으로 연산을 수행한다.

