취준생, 주니어를 위한 세미나를 듣다 보면 기본기를 강조한다.
나는 서버(백엔드) 직무를 희망하는 사람으로서 자바를 잘 하고 싶은데
"잘"한다는 건 어느 정도이고 자바에서는 어디까지 알아야 되는 걸까 궁금했다.
(정답은 알 수 없고 정답이 있다면 양극단 중간이겠지만,,)

강연자, 현업자분들께 이러한 이야기를 들려드리면 자바에선 JVM에 대해서 잘 알아야 한다고 말씀하신다.
JVM을 처음 배울 때는 가볍게 자바 바이트코드를 실행할 수 있는 가상머신이다. 운영체제에 상관없이 자바를 사용할 수 있게 해준다,, 그쯤까지 학습하는데.. 뭔가 더 있는 거 같아 이번 기회로 조금 더 깊게 알아보기로 했다.

---

순서는 다음 과같이 진행해 보기로,,

- JVM이란 무엇인가
- 바이트코드란 무엇인가
- JIT 컴파일러란 무엇이며 어떻게 동작하는가
- JDK와 JRE의 차이는 무엇인가.

Plus

- 자바 메모리 구조

---

# 1. JVM이란 무엇인가? 🌐

- JVM(Java Virtual Machine)은 자바 바이트코드를 실행할 수 있는 가상 머신이다.
- 자바로 작성된 프로그램은 자바 컴파일러에 의해 바이트코드로 변환되고, 이 바이트코드는 JVM 위에서 된다.
- JVM은 자바 프로그램이 다양한 운영 체제에서 변경 없이 실행될 수 있도록 하는 플랫폼 독립적인 환경을 제공한다.
- 즉, "한 번 작성하면 어디서나 실행된다(Write Once, Run Anywhere)"는 자바의 슬로건을 실현하는 핵심 기술이다.

---

여기까지는 기본서에서 학습할 수 있는 내용인데 더 깊게 가보자.

# 1-1 자바 애플리케이션의 실행 과정을 알아보자

![](https://velog.velcdn.com/images/harperkwon/post/a68bee26-5284-43bf-a99a-883673aa3d35/image.png)


### **1. 컴파일 단계** 🛠️ :

- 자바 소스 코드는 `.java` 확장자를 가진 파일(예: `Hello.java`)로 작성된다. 이 코드는 자바 컴파일러(javac)에 의해 컴파일되어, JVM이 이해할 수 있는 바이트코드가 포함된 `.class` 파일(예: `Hello.class`)로 변환된다.

### **2. 클래스 로딩** 🔍 :

- JVM이 시작하면, 클래스 로더는 필요한 클래스 파일들을 로드하고, 이들을 메소드 영역(Method Area)에 배치한다. 메소드 영역은 클래스 레벨의 정보(구조, 상수, 필드, 메소드 코드 등)를 저장하는 메모리 영역이다.

### **3. 실행 과정** ▶️:

- **클래스 실행**: JVM의 실행 엔진은 메소드 영역에 로드된 클래스 정보를 사용하여 프로그램을 실행한다. 초기 실행은 인터프리터 방식으로 수행되며, 빈번하게 사용되는 코드는 JIT 컴파일러에 의해 최적화되어 네이티브 코드로 변환된다.
- **HotSpot JVM**: HotSpot은 고성능 JVM 구현체 중 하나로, JIT 컴파일러의 성능 향상을 통해 Java 애플리케이션의 실행 속도를 크게 개선한다. HotSpot은 OpenJDK 프로젝트의 일부이다.

---

여기까지도 기본서에서 다루는 거 같다,,

JVM의 핵심은 메모리 구조 아닐까..?

# 1-2 JVM의 메모리 구조를 알아보자



![](https://velog.velcdn.com/images/harperkwon/post/a7dd84d0-5ea7-4381-b1bf-01f99fc7a3fc/image.png)


### **메모리 구조** 💾

### 1. **메소드 영역(Method Area) & 힙(Heap)**:

- 이 두 영역은 모든 스레드에 의해 공유되며, 멀티 스레드 환경에서 데이터 동기화가 필요하다.
- **메소드 영역**은 클래스 수준의 정보(클래스 구조, 상수, 필드 데이터, 메소드 코드 등)를 저장한다.
- **힙**은 런타임에 생성되는 모든 객체를 저장하는 영역으로, 가비지 컬렉터가 활동하는 주요 영역이다.가비지 컬렉션은 사용되지 않는 객체를 자동으로 감지하고 메모리를 회수한다.

### 2. **JVM 스택(JVM Stacks)** 📚:

- JVM은 실행 중인 각 스레드에 대해 별도의 JVM 스택을 할당한다. 이 스택은 해당 스레드가 실행하는 메소드에 대한 정보를 저장하는 데 사용된다.
- **프레임(Frame)**:
    - 프레임은 특정 메소드의 실행을 위한 데이터를 포함하며, 다음과 같은 세부 요소로 구성된다.
        - Local Variables Array: 메소드의 매개변수와 지역 변수를 저장한다. 인덱스로 접근되며, 예를 들어 this 참조는 인덱스 0에, 메소드의 첫 번째 매개변수는 인덱스 1에 저장된다.
        - Operand Stack: 메소드 실행 중 발생하는 연산의 중간 결과를 저장하는 스택이다.
        - Current Class References: 현재 실행 중인 클래스의 상수 풀 및 참조를 포함한다.
- **프레임의 생명주기** 🔄:
    - 메소드의 실행이 종료되거나, 메소드 내에서 예외가 발생하여 비정상적으로 종료될 경우, 해당 메소드에 대응하는 프레임은 스택에서 제거된다. 이는 메소드 호출이 종료되면 관련된 리소스가 자동으로 정리되어 메모리 효율성을 보장하는 매커니즘이다.

### 3. **프로그램 카운터 레지스터(PC Register)** 💡:

- 각 스레드는 현재 실행 중인 JVM 명령어의 주소를 추적하기 위한 프로그램 카운터 레지스터를 가진다.

### 4. **네이티브 메소드 스택(Native Method Stacks)** 🌍:

- 자바 이외의 언어로 작성된 네이티브 메소드를 실행하기 위해 JVM은 별도의 네이티브 메소드 스택을 유지다.

---

메모리 구조를 알아보았으니 사용되는 바이트코드를 알아보자.

# 2. 바이트코드란 무엇인가?

![](https://velog.velcdn.com/images/harperkwon/post/f563a49c-71a1-466f-be3f-aecfdda6ee33/image.png)


JVM(Java Virtual Machine)에서 말하는 바이트코드는 자바 소스 코드가 컴파일된 후의 중간 형태이다. 자바에서는 소스 코드(`.java` 파일)를 작성한 후, 이를 자바 컴파일러(`javac`)를 통해 컴파일한다. 이 과정에서 생성되는 것이 바로 바이트코드로, `.class` 파일 형태로 저장된다. 바이트코드는 기계어 코드가 아니라, JVM이 이해하고 실행할 수 있는 특정 형태의 코드이다. 이 바이트코드는 특정 하드웨어에 종속되지 않기 때문에, 어떤 플랫폼의 JVM 위에서도 실행될 수 있는 플랫폼 독립적인 특성을 가진다. 즉, 자바 프로그램은 "한 번 작성하면 어디서나 실행된다(Write Once, Run Anywhere)"라는 이점을 가지게 된다.

## 바이트코드의 주요 특징은 다음과 같다:

## 1. **플랫폼 독립성** 🌍:

- 바이트코드는 JVM이 설치되어 있는 모든 운영 체제에서 실행될 수 있다. 이는 JVM이 바이트코드를 해당 운영 체제가 이해할 수 있는 기계어로 변환하기 떄문이다.

## 2. **보안** 🔒:

- 바이트코드는 실행 전에 JVM에 의해 검증되므로, 코드가 안전하지 않은 작업을 수행하지 않도록 보장한다. 이는 자바 애플리케이션의 보안성을 높인다.

## 3. **성능** ⚡:

- 처음에는 바이트코드가 인터프리터 방식으로 실행되어 성능이 낮다는 인식이 있었지만, JIT(Just-In-Time) 컴파일러의 도입으로 런타임에 바이트코드를 기계어로 컴파일하여 실행 속도를 크게 향상시켰다.

## 4. **이식성** 🚀:

- 바이트코드의 플랫폼 독립적인 특성은 자바 애플리케이션을 다양한 환경에서 쉽게 이식할 수 있게 한다.

그래서 바이트 코드는 왜 쓰는가? 정리를 해보자면

바이트코드는 자바의 중간 표현(IR) 형태로, 자바 가상 머신이 실행하기 전의 코드이다. JVM은 이 바이트코드를 로드하고, 검증하며, 실행하는 역할을 한다. 바이트코드가 이러한 과정을 거치며 실행되는 방식 덕분에, 자바는 고성능, 보안, 이식성 및 플랫폼 독립성이라는 중요한 이점을 제공한다.

---

JVM 메모리, 바이트코드 챙겼으니 JIT 컴파일러에 대해서 알아보자.

# 3. JIT 컴파일러란 무엇이며 어떻게 동작하는가? 🚀

JIT(Just-In-Time) 컴파일러는 JVM(Java Virtual Machine)에서 중요한 성능 최적화 도구 중 하나이다. HotSpot JVM에 구현된 JIT 컴파일러는 자바 프로그램의 실행 속도를 크게 향상시키는 핵심 기술이다. 이 컴파일러는 프로그램이 실행되는 동안 실시간으로 바이트코드를 기계어로 변환하는 역할을 한다. 이 과정은 프로그램의 실행 초기에는 인터프리터 방식으로 수행되며, 이후 JIT 컴파일러가 개입하여 성능이 중요한 코드 부분을 집중적으로 최적화한다..

### JIT 컴파일러의 동작 방식:

1. **초기 처리** 🛠️: Java 컴파일러(javac)는 자바 소스 코드를 바이트코드(.class 파일)로 변환한다. 이 바이트코드는 JVM의 클래스 로더에 의해 로드되고, 실행 엔진에 의해 메모리 상에 배치된다.
2. **인터프리터와 JIT의 결합** 🔗: 실행 엔진 내부에는 인터프리터와 JIT 컴파일러가 존재한다. 초기에는 인터프리터가 바이트코드를 한 줄씩 실행한다. 이 과정에서 실행 중인 프로그램을 모니터링하여 자주 호출되는 코드(핫스팟)를 식별한다.
3. **JIT 컴파일 과정** 🔄: 식별된 핫스팟은 JIT 컴파일러에 의해 전체적으로 컴파일되어 기계어 코드로 변환된다. 이렇게 컴파일된 코드는 캐시에 저장되어, 이후에는 인터프리팅 없이 직접 실행되어 성능이 향상된다.
4. **성능 최적화 기술** ⚙️:
    - **Hot Spot Detection**: 루프 등 중복적인 해석이 발생하는 부분을 기계어로 직접 컴파일한다.
    - **Method Inlining**: 메모리 공간상 가까운 객체와 메소드들을 최적화하여 호출 비용을 줄인다. 필요에 따라 이 최적화를 취소하고 재최적화할 수도 있다.
5. **동적 최적화** 🔄: JIT 컴파일러는 프로그램의 실행 패턴 변화에 따라 동적으로 최적화를 수행하고, 필요한 경우 이전의 최적화를 취소하고 재최적화를 할 수 있다. 이는 static 언어와 비교하여 뛰어난 유연성을 제공한다.

오케이,, 정리를 해보자.

JIT 컴파일러의 이러한 동작 방식은 자바 애플리케이션의 실행 속도를 향상시키는 동시에, 안정성과 메모리 공간의 안전성을 보장한다. 모든 자바 객체는 독립적인 힙 공간에서 수행되며, 외부 해킹으로부터 안전한 실행이 가능하다. 또한, JIT 컴파일러는 성능을 높이기 위한 다양한 기술들을 효율적으로 작동시켜, 자바 기반 애플리케이션의 디버깅 및 유지보수에 유리한 환경을 제공한다. 이러한 고급 컴파일 기술들은 Java 1.6 이후 HotSpot 엔진의 성능 향상을 통해 더욱 발전하였다.

---

마지막으로 JDK, JRE에 대해서 알아보자.

# 4. JDK와 JRE의 차이점 이해하기

자바 개발의 세계에 발을 들이면 가장 처음 마주치는 용어들 중에 'JDK'와 'JRE'가 있다. 이 둘은 자바 프로그래밍과 밀접한 관련이 있는데, 각각의 역할과 차이점에 대해 명확히 알아두는 것이 중요하다.

### JRE (Java Runtime Environment)

'JRE'는 자바 런타임 환경이라고 해서, 자바 애플리케이션을 실행시키기 위한 소프트웨어 패키지다. 단순히 말해, 자바로 작성된 프로그램을 실행하고 싶을 때 필요한 모든 것이 담겨 있다.

JRE는 두 가지 주요 구성 요소를 포함한다:

1. **JVM (Java Virtual Machine)**: 이는 자바 애플리케이션을 실제로 실행하는 '가상' 컴퓨터로, 자바 바이트코드를 운영체제가 이해할 수 있는 코드로 변환하고 실행한다.
2. **Class Libraries**: 자바 표준 라이브러리로, 자바 프로그램이 실행될 때 필요한 다양한 기능들(파일 입출력, 네트워킹 등)을 제공하는 미리 작성된 코드의 집합이다.

### JDK (Java Development Kit)

JDK는 '자바 개발 키트'로, 자바 애플리케이션을 개발할 때 필요한 프로그램의 모음이다. JRE를 포함하여, 실제로 자바로 프로그래밍을 할 때 필요한 다양한 도구들이 포함되어 있다.

JDK는 다음과 같은 추가적인 구성 요소를 포함한다:

1. **Compilers**: 소스 코드를 작성한 후, 이를 JVM이 이해할 수 있는 바이트코드로 변환하는 'javac' 컴파일러가 포함되어 있다.
2. **Debuggers**: 코드에서 버그를 찾아 해결할 수 있도록 도와주는 디버깅 도구이다.
3. **JavaDoc**: 개발자가 작성한 코드에 대한 문서를 생성할 수 있도록 해주는 도구이다.

---

# 자바 메모리 구조 **(Java Memory Structure)**

예시

![](https://velog.velcdn.com/images/harperkwon/post/b7e9b19d-fdb2-4fc1-9a05-59ff9232ce9b/image.png)


자바의 메모리 구조는 크게 메서드 영역, 스택 영역, 힙 영역 3개로 나눌 수 있다.

- **메서드 영역**: 클래스 정보를 보관한다. 이 클래스 정보가 테슬라 생산 틀이다.
- **스택 영역**: 실제 프로그램이 실행되는 영역이다. 메서드를 실행할 때 마다 하나씩 쌓인다.
- **힙 영역**: 객체(인스턴스)가 생성되는 영역이다. `new` 명령어를 사용하면 이 영역을 사용한다. 쉽게 이야기해서 테슬라 생산 틀로부터 생성된 테슬라가 존재하는 공간이다. 참고로 배열도 이 영역에 생성된다.

# 자바 메모리 구조

![](https://velog.velcdn.com/images/harperkwon/post/b490bcdd-97c5-4718-bcbb-3673c640a5bd/image.png)


- 메서드 영역(Method Area)**: 메서드 영역은 프로그램을 실행하는데 필요한 공통 데이터를 관리한다. 이 영역은 프로그램의 모든 영역에서 공유한다.
    - 클래스 정보: 클래스의 실행 코드(바이트 코드), 필드, 메서드와 생성자 코드등 모든 실행 코드가 존재한다.
    - static 영역: `static` 변수들을 보관한다.
    - 런타임 상수 풀: 프로그램을 실행하는데 필요한 공통 리터럴 상수를 보관한다. 예를 들어서 프로그램에`"hello"` 라는 리터럴 문자가 있으면 이런 문자를 공통으로 묶어서 관리한다. 이 외에도 프로그램을 효율적으로 관리하기 위한 상수들을 관리한다.
- **스택 영역(Stack Area)**: 자바 실행 시, 하나의 실행 스택이 생성된다. 각 스택 프레임은 지역 변수, 중간 연산 결과, 메서드 호출 정보 등을 포함한다.
    - 스택 프레임: 스택 영역에 쌓이는 네모 박스가 하나의 스택 프레임이다. 메서드를 호출할 때 마다 하나의 스택 프레임이 쌓이고, 메서드가 종료되면 해당 스택 프레임이 제거된다.
- **힙 영역(Heap Area)**: 객체(인스턴스)와 배열이 생성되는 영역이다. 가비지 컬렉션(GC)이 이루어지는 주요 영역이며, 더 이상 참조되지 않는 객체는 GC에 의해 제거된다.

참고: 스택 영역은 더 정확히는 각 쓰레드별로 하나의 실행 스택이 생성된다. 따라서 쓰레드 수 만큼 스택 영역이 생성된다. 지금은 쓰레드를 1개만 사용하므로 스택 영역도 하나이다. 쓰레드에 대한 부분은 멀티 쓰레드를 학습해 야 이해할 수 있다.

**메서드 코드는 메서드 영역에**

![](https://velog.velcdn.com/images/harperkwon/post/d9f9e3ab-e636-4dbe-8821-63fc0f8461b1/image.png)


자바에서 특정 클래스로 100개의 인스턴스를 생성하면, 힙 메모리에 100개의 인스턴스가 생긴다. 각각의 인스턴스는 내부에 변수와 메서드를 가진다. 같은 클래스로 부터 생성된 객체라도, 인스턴스 내부의 변수 값은 서로 다를 수 있지만, 메서드는 공통된 코드를 공유한다. 따라서 객체가 생성될 때, 인스턴스 변수에는 메모리가 할당되지만, 메서드에 대한 새로운 메모리 할당은 없다. 메서드는 메서드 영역에서 공통으로 관리되고 실행된다.

정리하면 인스턴스의 메서드를 호출하면 실제로는 메서드 영역에 있는 코드를 불러서 수행한다.
